
并发|并行

线程安全

减小锁粒度是指缩小锁定对象的范围，从而减小锁冲突的可能性，从而提高系统的并发能力。
减小锁粒度是一种削弱多线程锁竞争的有效手段。

如果我们对整个 HashMap 加锁，可以得到线程安全的对象，但是加锁粒度太大。
Segment 的大小也被称为 ConcurrentHashMap 的并发度。


默认情况下一个 ConcurrentHashMap 被进一步细分为 16 个段 Segment，就是锁的并发度

ConcurrentHashMap 是由 Segment 数组结构和 HashEntry 数组结构组成，
Segment 是一种可重入锁 ReentrantLock，
HashEntry 用于存储键值对数据。

每个 Segment 守护一个 HashEntry 数组里的元素,
当对 HashEntry 数组的数据进行修改时，
必须首先获得它对应的 Segment 锁。




--------------------------------------------------------------------------------------------------



wait 和 notify 的异同

wait|notify:一定要在线程同步中使用,并且是同一个锁的获取和释放操作


wait是Object的public方法，所有class都可以调用，只能在synchronized{}中使用，wait后必需与notify配合唤醒线程

sleep是Thread的static方法，任何地方都可以使用，sleep只是暂停当前线程但是不释放任何锁，休眠时间到就自动唤醒线程


--------------------------------------------------------------------------------------------------


使线程的循环退出，正常执行到结尾，这样线程也会正常退出，不推荐使用Thread.stop()方法强行终止线程(已经被废弃，极端不安全)

使用Thread.currentThread().isInterrupted()方法判断线程的中断标志来退出循环，使用Thread.interrupt()方法中断线程

--------------------------------------------------------------------------------------------------


在JAVA线程中，通过一个int priority来控制优先级，范围为1-10，其中10最高，默认值为5。优先级越高分配到的资源越多。


两个交替执行的线程合并为顺序执行的线程。比如在线程B中调用了线程A的Join()方法，直到线程A执行完毕后，才会继续执行线程B。

Thread.yield()方法：暂停当前正在执行的线程并执行其他线程（可能没有效果）。
大多数情况下，yield()将导致线程从运行状态转到可运行状态，但有可能没有效果。
实际中无法保证yield()达到让步的目的，让步的线程可能被线程调度程序再次选中。



多线程并发的特性（三个）
1.操作原子性
2.内存可见性
3.指令有序性

指令重排不会影响单个线程的结果，
但会影响多线程并发执行的准确性，

多线程之间通过共享内存进行通信。

多线程死锁:同步中嵌套同步,导致锁无法释放。

--------------------------------------------------------------------------------------------------


Java Memory Model线程操作内存基本规则：
第一条关于线程的本地内存与主内存：线程对共享变量的所有操作都必须在自己的本地内存中进行，不能直接从主内存中读写。
第二条关于线程间本地内存：不同线程无法直接访问其他线程本地内存中的变量，线程间变量值的传递需要经过主内存来完成。

Java内存结构，和Java虚拟机的运行时区域有关。 
Java对象模型，和Java对象在虚拟机中的表现形式有关。 
Java内存模型，和Java的并发编程有关。

JMM定义了一套在多线程读写共享数据时，对共享数据的可见性，有序性，原子性的原则和保障。



synchronized可以保证同一时刻只有一个线程执行被修饰的方法或者代码块；
还可以保证共享变量的内存可见性；
代码重排序也不会影响其执行结果；



synchronized：编译成字节码后就是monitor enter和monitor exit两条指令


JMM关于synchronized的两条规定：
线程解锁前（退出同步代码块时）：必须把自己工作内存中共享变量的最新值刷新
到主内存中

线程加锁时（进入同步代码块时）：将清空本地内存中共享变量的值，从而使用共
享变量时需要从主内存中重新读取最新的值（加锁与解锁是同一把锁）

volatile是轻量级的synchronized同步

volatile关键字
可以保证内存可见性
可以保证指令有序性
无法保证操作原子性

进程全局内存和线程工作内存
线程改变变量只会改变线程工作内存，不会改变进程全局内存，导致其他线程工作内存不变
System.out.println()使用了synchronized关键字会导致volatile关键字效果不明显

ThreadLocal：存放线程私有数据


可重入锁表示同一线程可重复获取锁
公平锁表示获取锁依据先到先得原则

读写锁ReentrantReadWriteLock
允许同一时刻多个读线程访问，但是写线程和其他线程均被阻塞。

wait/notify模型

Lock和Condition组合使用
Lock.lock()
Condition.await()/signal()
Lock.unlock()


--------------------------------------------------------------------------------------------------





synchronized 和 ReentrantLock 的异同

1.关键字
//锁定变量
synchronized(this) {
    //代码块
}

//锁定对象
public synchronized return method(Class param) {
    //方法
}

//锁定类
public static synchronized return method(Class param) {
    //静态方法
}

Lock lock = new ReentrantLock(); 
lock.lock();
// 
lock.unlock();

同：
1.协调多线程对共享对象、变量的访问
2.可重入锁，同一线程可以多次获得同一个锁
3.保证了线程的互斥性和内存的可见性

异：
1. ReentrantLock 显式获得和释放锁，synchronized 隐式获得和释放锁
2. ReentrantLock 可响应中断、可轮回，synchronized 不可以响应中断的，为处理锁的不可用性提供了更高的灵活性
3. ReentrantLock 是 API 级别的，synchronized 是 JVM 级别的
4. ReentrantLock 可以实现公平锁
5. ReentrantLock 通过 Condition 可以绑定多个条件
6. 底层实现不一样， synchronized 是同步阻塞，使用的是悲观并发策略，lock 是同步非阻塞，采用的是乐观并发策略
7. Lock 是一个接口，ReentrantLock是实现了Lock接口的类，而 synchronized 是 Java 中的关键字，synchronized 是内置的语言实现。
8. synchronized 在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而 Lock 在发生异常时，如果没有主动通过 unLock()去释放锁，则很可能造成死锁现象，因此使用 Lock 时需要在 finally 块中释放锁。
9. Lock 可以让等待锁的线程响应中断，而 synchronized 却不行，使用 synchronized 时，等待的线程会一直等待下去，不能够响应中断。
10. 通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到。
11. Lock 可以提高多个线程进行读操作的效率，既就是实现读写锁等。





--------------------------------------------------------------------------------------------------




线程调度：
抢占式调度
协同式调度

先来先服务（FCFS）调度算法
短作业优先(SJF)调度算法


非抢占式优先权算法
抢占式优先权调度算法
高响应比优先调度算法


CAS（Compare And Swap）比较并交换

JVM的CAS是使用CPU提供的CMPXCHG指令

使用锁机制和循环CAS实现原子操作
CAS只能保证一个共享变量的原子操作
多个共享变量的原子操作可以使用锁机制




乐观锁机制-锁自旋-非阻塞算法 
jdk1.5:java.util.concurrent.atomic


Abstract Queued Synchronizer 抽象的队列式的同步器:
定义了一套多线程访问共享资源的同步器框架
同步器的实现是 ABS 核心（state 资源状态计数）


ReentrantLock/Semaphore/CountDownLatch
独占资源:只有一个线程能执行 ReentrantLock
共享资源:多个线程可同时执行 CountDownLatch



1．isHeldExclusively()：该线程是否正在独占资源。只有用到 condition 才需要去实现它。
2．tryAcquire(int)：独占方式。尝试获取资源，成功则返回 true，失败则返回 false。
3．tryRelease(int)：独占方式。尝试释放资源，成功则返回 true，失败则返回 false。
4．tryAcquireShared(int)：共享方式。尝试获取资源。负数表示失败；0 表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。
5．tryReleaseShared(int)：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回 false。


